// Generated by CoffeeScript 2.4.1
(function() {
  //###########################################################################
  //     Copyright (C) 2014-2017 by Vaughn Iverson
  //     meteor-job-class is free software released under the MIT/X11 license.
  //     See included LICENSE file for details.
  //###########################################################################

  // Exports Job object
  var Job, JobQueue, _clearInterval, _setImmediate, _setInterval, concatReduce, isBoolean, isFunction, isInteger, isNonEmptyString, isNonEmptyStringOrArrayOfNonEmptyStrings, methodCall, optionsHelp, reduceCallbacks, splitLongArray,
    splice = [].splice,
    indexOf = [].indexOf;

  methodCall = function(root, method, params, cb, after = (function(ret) {
      return ret;
    })) {
    var apply, name, ref, ref1, ref2, ref3;
    apply = (ref = (ref1 = Job._ddp_apply) != null ? ref1[(ref2 = root.root) != null ? ref2 : root] : void 0) != null ? ref : Job._ddp_apply;
    if (typeof apply !== 'function') {
      throw new Error("Job remote method call error, no valid invocation method found.");
    }
    name = `${(ref3 = root.root) != null ? ref3 : root}_${method}`;
    if (cb && typeof cb === 'function') {
      return apply(name, params, (err, res) => {
        if (err) {
          return cb(err);
        }
        return cb(null, after(res));
      });
    } else {
      return after(apply(name, params));
    }
  };

  optionsHelp = function(options, cb) {
    var ref;
    // If cb isn't a function, it's assumed to be options...
    if ((cb != null) && typeof cb !== 'function') {
      options = cb;
      cb = void 0;
    } else {
      if (!(typeof options === 'object' && options instanceof Array && options.length < 2)) {
        throw new Error('options... in optionsHelp must be an Array with zero or one elements');
      }
      options = (ref = options != null ? options[0] : void 0) != null ? ref : {};
    }
    if (typeof options !== 'object') {
      throw new Error('in optionsHelp options not an object or bad callback');
    }
    return [options, cb];
  };

  splitLongArray = function(arr, max) {
    var i, k, ref, results;
    if (!(arr instanceof Array && max > 0)) {
      throw new Error('splitLongArray: bad params');
    }
    results = [];
    for (i = k = 0, ref = Math.ceil(arr.length / max); (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      results.push(arr.slice((i * max), ((i + 1) * max)));
    }
    return results;
  };

  // This function soaks up num callbacks, by default returning the disjunction of Boolean results
  // or returning on first error.... Reduce function causes different reduce behavior, such as concatenation
  reduceCallbacks = function(cb, num, reduce = (function(a, b) {
      return a || b;
    }), init = false) {
    var cbCount, cbErr, cbRetVal;
    if (cb == null) {
      return void 0;
    }
    if (!(typeof cb === 'function' && num > 0 && typeof reduce === 'function')) {
      throw new Error('Bad params given to reduceCallbacks');
    }
    cbRetVal = init;
    cbCount = 0;
    cbErr = null;
    return function(err, res) {
      if (!cbErr) {
        if (err) {
          cbErr = err;
          return cb(err);
        } else {
          cbCount++;
          cbRetVal = reduce(cbRetVal, res);
          if (cbCount === num) {
            return cb(null, cbRetVal);
          } else if (cbCount > num) {
            throw new Error(`reduceCallbacks callback invoked more than requested ${num} times`);
          }
        }
      }
    };
  };

  concatReduce = function(a, b) {
    if (!(a instanceof Array)) {
      a = [a];
    }
    return a.concat(b);
  };

  isInteger = function(i) {
    return typeof i === 'number' && Math.floor(i) === i;
  };

  isBoolean = function(b) {
    return typeof b === 'boolean';
  };

  isFunction = function(f) {
    return typeof f === 'function';
  };

  isNonEmptyString = function(s) {
    return typeof s === 'string' && s.length > 0;
  };

  isNonEmptyStringOrArrayOfNonEmptyStrings = function(sa) {
    var s;
    return isNonEmptyString(sa) || sa instanceof Array && sa.length !== 0 && ((function() {
      var k, len, results;
      results = [];
      for (k = 0, len = sa.length; k < len; k++) {
        s = sa[k];
        if (isNonEmptyString(s)) {
          results.push(s);
        }
      }
      return results;
    })()).length === sa.length;
  };

  // This smooths over the various different implementations...
  _setImmediate = function(func, ...args) {
    if ((typeof Meteor !== "undefined" && Meteor !== null ? Meteor.setTimeout : void 0) != null) {
      return Meteor.setTimeout(func, 0, ...args);
    } else if (typeof setImmediate !== "undefined" && setImmediate !== null) {
      return setImmediate(func, ...args);
    } else {
      // Browser fallback
      return setTimeout(func, 0, ...args);
    }
  };

  _setInterval = function(func, timeOut, ...args) {
    if ((typeof Meteor !== "undefined" && Meteor !== null ? Meteor.setInterval : void 0) != null) {
      return Meteor.setInterval(func, timeOut, ...args);
    } else {
      // Browser / node.js fallback
      return setInterval(func, timeOut, ...args);
    }
  };

  _clearInterval = function(id) {
    if ((typeof Meteor !== "undefined" && Meteor !== null ? Meteor.clearInterval : void 0) != null) {
      return Meteor.clearInterval(id);
    } else {
      // Browser / node.js fallback
      return clearInterval(id);
    }
  };

  //##################################################################
  JobQueue = class JobQueue {
    constructor(root1, type1, ...options) {
      var ref, ref1, ref2, ref3, ref4, worker;
      ref = options, [...options] = ref, [worker] = splice.call(options, -1);
      this.root = root1;
      this.type = type1;
      this.worker = worker;
      if (!(this instanceof JobQueue)) {
        return new JobQueue(this.root, this.type, ...options, this.worker);
      }
      [options, this.worker] = optionsHelp(options, this.worker);
      if (!isNonEmptyString(this.root)) {
        throw new Error("JobQueue: Invalid root, must be nonempty string");
      }
      if (!isNonEmptyStringOrArrayOfNonEmptyStrings(this.type)) {
        throw new Error("JobQueue: Invalid type, must be nonempty string or array of nonempty strings");
      }
      if (!isFunction(this.worker)) {
        throw new Error("JobQueue: Invalid worker, must be a function");
      }
      this.errorCallback = (ref1 = options.errorCallback) != null ? ref1 : function(e) {
        return console.error("JobQueue: ", e);
      };
      if (!isFunction(this.errorCallback)) {
        throw new Error("JobQueue: Invalid errorCallback, must be a function");
      }
      this.pollInterval = (options.pollInterval != null) && !options.pollInterval ? Job.forever : !((options.pollInterval != null) && isInteger(options.pollInterval)) ? 5000 : options.pollInterval; // ms
      if (!(isInteger(this.pollInterval) && this.pollInterval >= 0)) {
        throw new Error("JobQueue: Invalid pollInterval, must be a positive integer");
      }
      this.concurrency = (ref2 = options.concurrency) != null ? ref2 : 1;
      if (!(isInteger(this.concurrency) && this.concurrency >= 0)) {
        throw new Error("JobQueue: Invalid concurrency, must be a positive integer");
      }
      this.payload = (ref3 = options.payload) != null ? ref3 : 1;
      if (!(isInteger(this.payload) && this.payload >= 0)) {
        throw new Error("JobQueue: Invalid payload, must be a positive integer");
      }
      this.prefetch = (ref4 = options.prefetch) != null ? ref4 : 0;
      if (!(isInteger(this.prefetch) && this.prefetch >= 0)) {
        throw new Error("JobQueue: Invalid prefetch, must be a positive integer");
      }
      this.workTimeout = options.workTimeout; // No default
      if ((this.workTimeout != null) && !(isInteger(this.workTimeout) && this.workTimeout >= 0)) {
        throw new Error("JobQueue: Invalid workTimeout, must be a positive integer");
      }
      this.callbackStrict = options.callbackStrict;
      if ((this.callbackStrict != null) && !isBoolean(this.callbackStrict)) {
        throw new Error("JobQueue: Invalid callbackStrict, must be a boolean");
      }
      this._workers = {};
      this._tasks = [];
      this._taskNumber = 0;
      this._stoppingGetWork = void 0;
      this._stoppingTasks = void 0;
      this._interval = null;
      this._getWorkOutstanding = false;
      this.paused = true;
      this.resume();
    }

    _getWork() {
      var numJobsToGet, options;
      // Don't reenter, or run when paused or stopping
      if (!(this._getWorkOutstanding || this.paused)) {
        numJobsToGet = this.prefetch + this.payload * (this.concurrency - this.running()) - this.length();
        if (numJobsToGet > 0) {
          this._getWorkOutstanding = true;
          options = {
            maxJobs: numJobsToGet
          };
          if (this.workTimeout != null) {
            options.workTimeout = this.workTimeout;
          }
          return Job.getWork(this.root, this.type, options, (err, jobs) => {
            var j, k, len;
            this._getWorkOutstanding = false;
            if (err) {
              return this.errorCallback(new Error(`Received error from getWork(): ${err}`));
            } else if ((jobs != null) && jobs instanceof Array) {
              if (jobs.length > numJobsToGet) {
                this.errorCallback(new Error(`getWork() returned jobs (${jobs.length}) in excess of maxJobs (${numJobsToGet})`));
              }
              for (k = 0, len = jobs.length; k < len; k++) {
                j = jobs[k];
                this._tasks.push(j);
                if (this._stoppingGetWork == null) {
                  _setImmediate(this._process.bind(this));
                }
              }
              if (this._stoppingGetWork != null) {
                return this._stoppingGetWork();
              }
            } else {
              return this.errorCallback(new Error("Nonarray response from server from getWork()"));
            }
          });
        }
      }
    }

    _only_once(fn) {
      var called;
      called = false;
      return () => {
        if (called) {
          this.errorCallback(new Error("Worker callback called multiple times"));
          if (this.callbackStrict) {
            throw new Error("JobQueue: worker callback was invoked multiple times");
          }
        }
        called = true;
        return fn.apply(this, arguments);
      };
    }

    _process() {
      var cb, job, next;
      if (!this.paused && this.running() < this.concurrency && this.length()) {
        if (this.payload > 1) {
          job = this._tasks.splice(0, this.payload);
        } else {
          job = this._tasks.shift();
        }
        job._taskId = `Task_${this._taskNumber++}`;
        this._workers[job._taskId] = job;
        next = () => {
          delete this._workers[job._taskId];
          if ((this._stoppingTasks != null) && this.running() === 0 && this.length() === 0) {
            return this._stoppingTasks();
          } else {
            _setImmediate(this._process.bind(this));
            return _setImmediate(this._getWork.bind(this));
          }
        };
        cb = this._only_once(next);
        return this.worker(job, cb);
      }
    }

    _stopGetWork(callback) {
      _clearInterval(this._interval);
      this._interval = null;
      if (this._getWorkOutstanding) {
        return this._stoppingGetWork = callback;
      } else {
        return _setImmediate(callback); // No Zalgo, thanks
      }
    }

    _waitForTasks(callback) {
      if (this.running() !== 0) {
        return this._stoppingTasks = callback;
      } else {
        return _setImmediate(callback); // No Zalgo, thanks
      }
    }

    _failJobs(tasks, callback) {
      var count, job, k, len, results;
      if (tasks.length === 0) { // No Zalgo, thanks
        _setImmediate(callback);
      }
      count = 0;
      results = [];
      for (k = 0, len = tasks.length; k < len; k++) {
        job = tasks[k];
        results.push(job.fail("Worker shutdown", (err, res) => {
          count++;
          if (count === tasks.length) {
            return callback();
          }
        }));
      }
      return results;
    }

    _hard(callback) {
      this.paused = true;
      return this._stopGetWork(() => {
        var i, r, ref, tasks;
        tasks = this._tasks;
        this._tasks = [];
        ref = this._workers;
        for (i in ref) {
          r = ref[i];
          tasks = tasks.concat(r);
        }
        return this._failJobs(tasks, callback);
      });
    }

    _stop(callback) {
      this.paused = true;
      return this._stopGetWork(() => {
        var tasks;
        tasks = this._tasks;
        this._tasks = [];
        return this._waitForTasks(() => {
          return this._failJobs(tasks, callback);
        });
      });
    }

    _soft(callback) {
      return this._stopGetWork(() => {
        return this._waitForTasks(callback);
      });
    }

    length() {
      return this._tasks.length;
    }

    running() {
      return Object.keys(this._workers).length;
    }

    idle() {
      return this.length() + this.running() === 0;
    }

    full() {
      return this.running() === this.concurrency;
    }

    pause() {
      if (this.paused) {
        return;
      }
      if (!(this.pollInterval >= Job.forever)) {
        _clearInterval(this._interval);
        this._interval = null;
      }
      this.paused = true;
      return this;
    }

    resume() {
      var k, ref, w;
      if (!this.paused) {
        return;
      }
      this.paused = false;
      _setImmediate(this._getWork.bind(this));
      if (!(this.pollInterval >= Job.forever)) {
        this._interval = _setInterval(this._getWork.bind(this), this.pollInterval);
      }
      for (w = k = 1, ref = this.concurrency; (1 <= ref ? k <= ref : k >= ref); w = 1 <= ref ? ++k : --k) {
        _setImmediate(this._process.bind(this));
      }
      return this;
    }

    trigger() {
      if (this.paused) {
        return;
      }
      _setImmediate(this._getWork.bind(this));
      return this;
    }

    shutdown(...options) {
      var cb, ref;
      ref = options, [...options] = ref, [cb] = splice.call(options, -1);
      [options, cb] = optionsHelp(options, cb);
      if (options.level == null) {
        options.level = 'normal';
      }
      if (options.quiet == null) {
        options.quiet = false;
      }
      if (cb == null) {
        if (!options.quiet) {
          console.warn("using default shutdown callback!");
        }
        cb = () => {
          return console.warn("Shutdown complete");
        };
      }
      switch (options.level) {
        case 'hard':
          if (!options.quiet) {
            console.warn("Shutting down hard");
          }
          return this._hard(cb);
        case 'soft':
          if (!options.quiet) {
            console.warn("Shutting down soft");
          }
          return this._soft(cb);
        default:
          if (!options.quiet) {
            console.warn("Shutting down normally");
          }
          return this._stop(cb);
      }
    }

  };

  Job = (function() {
    //##################################################################
    class Job {
      // Class methods
      static _setDDPApply(apply, collectionName) {
        if (typeof apply === 'function') {
          if (typeof collectionName === 'string') {
            if (this._ddp_apply == null) {
              this._ddp_apply = {};
            }
            if (typeof this._ddp_apply === 'function') {
              throw new Error("Job.setDDP must specify a collection name each time if called more than once.");
            }
            return this._ddp_apply[collectionName] = apply;
          } else if (!this._ddp_apply) {
            return this._ddp_apply = apply;
          } else {
            throw new Error("Job.setDDP must specify a collection name each time if called more than once.");
          }
        } else {
          throw new Error("Bad function in Job.setDDPApply()");
        }
      }

      // This needs to be called when not running in Meteor to use the local DDP connection.
      static setDDP(ddp = null, collectionNames = null, Fiber = null) {
        var collName, k, len, results;
        if (!((typeof collectionNames === 'string') || (collectionNames instanceof Array))) {
          // Handle optional collection string with Fiber present
          Fiber = collectionNames;
          collectionNames = [void 0];
        } else if (typeof collectionNames === 'string') {
          // If string, convert to array of strings
          collectionNames = [collectionNames];
        }
        results = [];
        for (k = 0, len = collectionNames.length; k < len; k++) {
          collName = collectionNames[k];
          if (!((ddp != null) && (ddp.close != null) && (ddp.subscribe != null))) {
            // Not the DDP npm package
            if (ddp === null && ((typeof Meteor !== "undefined" && Meteor !== null ? Meteor.apply : void 0) != null)) {
              // Meteor local server/client
              results.push(this._setDDPApply(Meteor.apply, collName));
            } else {
              // No other possibilities...
              throw new Error("Bad ddp object in Job.setDDP()");
            }
          } else if (ddp.observe == null) {
            results.push(this._setDDPApply(ddp.apply.bind(ddp), collName)); // This is the npm DDP package
          } else {
            if (Fiber == null) {
              results.push(this._setDDPApply(ddp.call.bind(ddp), collName));
            } else {
              // If Fibers in use under pure node.js,
              // make sure to yield and throw errors when no callback
              results.push(this._setDDPApply((function(name, params, cb) {
                var fib;
                fib = Fiber.current;
                ddp.call(name, params, function(err, res) {
                  if ((cb != null) && typeof cb === 'function') {
                    return cb(err, res);
                  } else {
                    if (err) {
                      return fib.throwInto(err);
                    } else {
                      return fib.run(res);
                    }
                  }
                });
                if ((cb != null) && typeof cb === 'function') {

                } else {
                  return Fiber.yield();
                }
              }), collName));
            } // This is a Meteor DDP connection object
          }
        }
        return results;
      }

      // Creates a job object by reserving the next available job of
      // the specified 'type' from the server queue root
      // returns null if no such job exists
      static getWork(root, type, ...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (typeof type === 'string') {
          type = [type];
        }
        if (options.workTimeout != null) {
          if (!(isInteger(options.workTimeout) && options.workTimeout > 0)) {
            throw new Error('getWork: workTimeout must be a positive integer');
          }
        }
        return methodCall(root, "getWork", [type, options], cb, (res) => {
          var doc, jobs;
          jobs = ((function() {
            var k, len, results;
            results = [];
            for (k = 0, len = res.length; k < len; k++) {
              doc = res[k];
              results.push(new Job(root, doc));
            }
            return results;
          })()) || [];
          if (options.maxJobs != null) {
            return jobs;
          } else {
            return jobs[0];
          }
        });
      }

      // Creates a job object by id from the server queue root
      // returns null if no such job exists
      static getJob(root, id, ...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.getLog == null) {
          options.getLog = false;
        }
        return methodCall(root, "getJob", [id, options], cb, (doc) => {
          if (doc) {
            return new Job(root, doc);
          } else {
            return void 0;
          }
        });
      }

      // Like the above, but takes an array of ids, returns array of jobs
      static getJobs(root, ids, ...options) {
        var cb, chunkOfIds, chunksOfIds, k, len, myCb, ref, retVal;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.getLog == null) {
          options.getLog = false;
        }
        retVal = [];
        chunksOfIds = splitLongArray(ids, 32);
        myCb = reduceCallbacks(cb, chunksOfIds.length, concatReduce, []);
        for (k = 0, len = chunksOfIds.length; k < len; k++) {
          chunkOfIds = chunksOfIds[k];
          retVal = retVal.concat(methodCall(root, "getJob", [chunkOfIds, options], myCb, (doc) => {
            var d, l, len1, results;
            if (doc) {
              results = [];
              for (l = 0, len1 = doc.length; l < len1; l++) {
                d = doc[l];
                results.push(new Job(root, d.type, d.data, d));
              }
              return results;
            } else {
              return null;
            }
          }));
        }
        return retVal;
      }

      // Pause this job, only Ready and Waiting jobs can be paused
      // Calling this toggles the paused state. Unpaused jobs go to waiting
      static pauseJobs(root, ids, ...options) {
        var cb, chunkOfIds, chunksOfIds, k, len, myCb, ref, retVal;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        retVal = false;
        chunksOfIds = splitLongArray(ids, 256);
        myCb = reduceCallbacks(cb, chunksOfIds.length);
        for (k = 0, len = chunksOfIds.length; k < len; k++) {
          chunkOfIds = chunksOfIds[k];
          retVal = methodCall(root, "jobPause", [chunkOfIds, options], myCb) || retVal;
        }
        return retVal;
      }

      // Resume this job, only Paused jobs can be resumed
      // Calling this toggles the paused state. Unpaused jobs go to waiting
      static resumeJobs(root, ids, ...options) {
        var cb, chunkOfIds, chunksOfIds, k, len, myCb, ref, retVal;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        retVal = false;
        chunksOfIds = splitLongArray(ids, 256);
        myCb = reduceCallbacks(cb, chunksOfIds.length);
        for (k = 0, len = chunksOfIds.length; k < len; k++) {
          chunkOfIds = chunksOfIds[k];
          retVal = methodCall(root, "jobResume", [chunkOfIds, options], myCb) || retVal;
        }
        return retVal;
      }

      // Move waiting jobs to the ready state, jobs with dependencies will not
      // be made ready unless force is used.
      static readyJobs(root, ids = [], ...options) {
        var cb, chunkOfIds, chunksOfIds, k, len, myCb, ref, retVal;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.force == null) {
          options.force = false;
        }
        retVal = false;
        chunksOfIds = splitLongArray(ids, 256);
        if (!(chunksOfIds.length > 0)) {
          chunksOfIds = [[]];
        }
        myCb = reduceCallbacks(cb, chunksOfIds.length);
        for (k = 0, len = chunksOfIds.length; k < len; k++) {
          chunkOfIds = chunksOfIds[k];
          retVal = methodCall(root, "jobReady", [chunkOfIds, options], myCb) || retVal;
        }
        return retVal;
      }

      // Cancel this job if it is running or able to run (waiting, ready)
      static cancelJobs(root, ids, ...options) {
        var cb, chunkOfIds, chunksOfIds, k, len, myCb, ref, retVal;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.antecedents == null) {
          options.antecedents = true;
        }
        retVal = false;
        chunksOfIds = splitLongArray(ids, 256);
        myCb = reduceCallbacks(cb, chunksOfIds.length);
        for (k = 0, len = chunksOfIds.length; k < len; k++) {
          chunkOfIds = chunksOfIds[k];
          retVal = methodCall(root, "jobCancel", [chunkOfIds, options], myCb) || retVal;
        }
        return retVal;
      }

      // Restart a failed or cancelled job
      static restartJobs(root, ids, ...options) {
        var cb, chunkOfIds, chunksOfIds, k, len, myCb, ref, retVal;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.retries == null) {
          options.retries = 1;
        }
        if (options.dependents == null) {
          options.dependents = true;
        }
        retVal = false;
        chunksOfIds = splitLongArray(ids, 256);
        myCb = reduceCallbacks(cb, chunksOfIds.length);
        for (k = 0, len = chunksOfIds.length; k < len; k++) {
          chunkOfIds = chunksOfIds[k];
          retVal = methodCall(root, "jobRestart", [chunkOfIds, options], myCb) || retVal;
        }
        return retVal;
      }

      // Remove a job that is not able to run (completed, cancelled, failed) from the queue
      static removeJobs(root, ids, ...options) {
        var cb, chunkOfIds, chunksOfIds, k, len, myCb, ref, retVal;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        retVal = false;
        chunksOfIds = splitLongArray(ids, 256);
        myCb = reduceCallbacks(cb, chunksOfIds.length);
        for (k = 0, len = chunksOfIds.length; k < len; k++) {
          chunkOfIds = chunksOfIds[k];
          retVal = methodCall(root, "jobRemove", [chunkOfIds, options], myCb) || retVal;
        }
        return retVal;
      }

      // Start the job queue
      // Deprecated!
      static startJobs(root, ...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        return methodCall(root, "startJobs", [options], cb);
      }

      // Stop the job queue, stop all running jobs
      // Deprecated!
      static stopJobs(root, ...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.timeout == null) {
          options.timeout = 60 * 1000;
        }
        return methodCall(root, "stopJobs", [options], cb);
      }

      // Start the job queue
      static startJobServer(root, ...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        return methodCall(root, "startJobServer", [options], cb);
      }

      // Shutdown the job queue, stop all running jobs
      static shutdownJobServer(root, ...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.timeout == null) {
          options.timeout = 60 * 1000;
        }
        return methodCall(root, "shutdownJobServer", [options], cb);
      }

      // Job class instance constructor. When "new Job(...)" is run
      constructor(rootVal, type, data) {
        var doc, ref, time;
        if (!(this instanceof Job)) {
          return new Job(rootVal, type, data);
        }
        // Set the root value
        this.root = rootVal;
        // Keep a copy of the original root value, whatever type that is
        this._root = rootVal;
        // Handle root as object with obj.root attribute
        if ((((ref = this.root) != null ? ref.root : void 0) != null) && typeof this.root.root === 'string') {
          this.root = this._root.root;
        }
        // Handle (root, doc) signature
        if ((data == null) && ((type != null ? type.data : void 0) != null) && ((type != null ? type.type : void 0) != null)) {
          if (type instanceof Job) {
            return type;
          }
          doc = type;
          data = doc.data;
          type = doc.type;
        } else {
          doc = {};
        }
        if (!(typeof doc === 'object' && typeof data === 'object' && typeof type === 'string' && typeof this.root === 'string')) {
          throw new Error(`new Job: bad parameter(s), ${this.root} (${typeof this.root}), ${type} (${typeof type}), ${data} (${typeof data}), ${doc} (${typeof doc})`);
        } else if ((doc.type != null) && (doc.data != null)) { // This case is used to create local Job objects from DDP calls
          this._doc = doc; // This is the normal "create a new object" case
        } else {
          time = new Date();
          this._doc = {
            runId: null,
            type: type,
            data: data,
            status: 'waiting',
            updated: time,
            created: time
          };
          this.priority().retry().repeat().after().progress().depends().log("Constructed");
        }
        return this;
      }

      // Override point for methods that have an echo option
      _echo(message, level = null) {
        switch (level) {
          case 'danger':
            console.error(message);
            break;
          case 'warning':
            console.warn(message);
            break;
          case 'success':
            console.log(message);
            break;
          default:
            console.info(message);
        }
      }

      // Adds a run dependancy on one or more existing jobs to this job
      // Calling with a falsy value resets the dependencies to []
      depends(jobs) {
        var depends, j, k, len;
        if (jobs) {
          if (jobs instanceof Job) {
            jobs = [jobs];
          }
          if (jobs instanceof Array) {
            depends = this._doc.depends;
            for (k = 0, len = jobs.length; k < len; k++) {
              j = jobs[k];
              if (!(j instanceof Job && (j._doc._id != null))) {
                throw new Error('Each provided object must be a saved Job instance (with an _id)');
              }
              depends.push(j._doc._id);
            }
          } else {
            throw new Error('Bad input parameter: depends() accepts a falsy value, or Job or array of Jobs');
          }
        } else {
          depends = [];
        }
        this._doc.depends = depends;
        this._doc.resolved = []; // This is where prior depends go as they are satisfied
        return this;
      }

      // Set the run priority of this job
      priority(level = 0) {
        var priority;
        if (typeof level === 'string') {
          priority = Job.jobPriorities[level];
          if (priority == null) {
            throw new Error('Invalid string priority level provided');
          }
        } else if (isInteger(level)) {
          priority = level;
        } else {
          throw new Error('priority must be an integer or valid priority level');
          priority = 0;
        }
        this._doc.priority = priority;
        return this;
      }

      // Sets the number of attempted runs of this job and
      // the time to wait between successive attempts
      // Default, do not retry
      retry(options = 0) {
        var base, ref;
        if (isInteger(options) && options >= 0) {
          options = {
            retries: options
          };
        }
        if (typeof options !== 'object') {
          throw new Error('bad parameter: accepts either an integer >= 0 or an options object');
        }
        if (options.retries != null) {
          if (!(isInteger(options.retries) && options.retries >= 0)) {
            throw new Error('bad option: retries must be an integer >= 0');
          }
          options.retries++;
        } else {
          options.retries = Job.forever;
        }
        if (options.until != null) {
          if (!(options.until instanceof Date)) {
            throw new Error('bad option: until must be a Date object');
          }
        } else {
          options.until = Job.foreverDate;
        }
        if (options.wait != null) {
          if (!(isInteger(options.wait) && options.wait >= 0)) {
            throw new Error('bad option: wait must be an integer >= 0');
          }
        } else {
          options.wait = 5 * 60 * 1000;
        }
        if (options.backoff != null) {
          if (ref = options.backoff, indexOf.call(Job.jobRetryBackoffMethods, ref) < 0) {
            throw new Error('bad option: invalid retry backoff method');
          }
        } else {
          options.backoff = 'constant';
        }
        this._doc.retries = options.retries;
        this._doc.repeatRetries = options.retries;
        this._doc.retryWait = options.wait;
        if ((base = this._doc).retried == null) {
          base.retried = 0;
        }
        this._doc.retryBackoff = options.backoff;
        this._doc.retryUntil = options.until;
        return this;
      }

      // Sets the number of times to repeatedly run this job
      // and the time to wait between successive runs
      // Default: repeat every 5 minutes, forever...
      repeat(options = 0) {
        var base, ref;
        if (isInteger(options) && options >= 0) {
          options = {
            repeats: options
          };
        }
        if (typeof options !== 'object') {
          throw new Error('bad parameter: accepts either an integer >= 0 or an options object');
        }
        if ((options.wait != null) && (options.schedule != null)) {
          throw new Error('bad options: wait and schedule options are mutually exclusive');
        }
        if (options.repeats != null) {
          if (!(isInteger(options.repeats) && options.repeats >= 0)) {
            throw new Error('bad option: repeats must be an integer >= 0');
          }
        } else {
          options.repeats = Job.forever;
        }
        if (options.until != null) {
          if (!(options.until instanceof Date)) {
            throw new Error('bad option: until must be a Date object');
          }
        } else {
          options.until = Job.foreverDate;
        }
        if (options.wait != null) {
          if (!(isInteger(options.wait) && options.wait >= 0)) {
            throw new Error('bad option: wait must be an integer >= 0');
          }
        } else {
          options.wait = 5 * 60 * 1000;
        }
        if (options.schedule != null) {
          if (typeof options.schedule !== 'object') {
            throw new Error('bad option, schedule option must be an object');
          }
          if (!((((ref = options.schedule) != null ? ref.schedules : void 0) != null) && options.schedule.schedules instanceof Array)) {
            throw new Error('bad option, schedule object requires a schedules attribute of type Array.');
          }
          if ((options.schedule.exceptions != null) && !(options.schedule.exceptions instanceof Array)) {
            throw new Error('bad option, schedule object exceptions attribute must be an Array');
          }
          options.wait = {
            schedules: options.schedule.schedules,
            exceptions: options.schedule.exceptions
          };
        }
        this._doc.repeats = options.repeats;
        this._doc.repeatWait = options.wait;
        if ((base = this._doc).repeated == null) {
          base.repeated = 0;
        }
        this._doc.repeatUntil = options.until;
        return this;
      }

      // Sets the delay before this job can run after it is saved
      delay(wait = 0) {
        if (!(isInteger(wait) && wait >= 0)) {
          throw new Error('Bad parameter, delay requires a non-negative integer.');
        }
        return this.after(new Date(new Date().valueOf() + wait));
      }

      // Sets a time after which this job can run once it is saved
      after(time = new Date(0)) {
        var after;
        if (typeof time === 'object' && time instanceof Date) {
          after = time;
        } else {
          throw new Error('Bad parameter, after requires a valid Date object');
        }
        this._doc.after = after;
        return this;
      }

      // Write a message to this job's log.
      log(message, ...options) {
        var base, cb, ref, ref1;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.level == null) {
          options.level = 'info';
        }
        if (typeof message !== 'string') {
          throw new Error('Log message must be a string');
        }
        if (!(typeof options.level === 'string' && (ref1 = options.level, indexOf.call(Job.jobLogLevels, ref1) >= 0))) {
          throw new Error('Log level options must be one of Job.jobLogLevels');
        }
        if (options.echo != null) {
          if (options.echo && Job.jobLogLevels.indexOf(options.level) >= Job.jobLogLevels.indexOf(options.echo)) {
            this._echo(`LOG: ${options.level}, ${this._doc._id} ${this._doc.runId}: ${message}`, options.level);
          }
          delete options.echo;
        }
        if (this._doc._id != null) {
          return methodCall(this._root, "jobLog", [this._doc._id, this._doc.runId, message, options], cb); // Log can be called on an unsaved job
        } else {
          if ((base = this._doc).log == null) {
            base.log = [];
          }
          this._doc.log.push({
            time: new Date(),
            runId: null,
            level: options.level,
            message: message
          });
          if ((cb != null) && typeof cb === 'function') {
            _setImmediate(cb, null, true); // DO NOT release Zalgo
          }
          return this; // Allow call chaining in this case
        }
      }

      
      // Indicate progress made for a running job. This is important for
      // long running jobs so the scheduler doesn't assume they are dead
      progress(completed = 0, total = 1, ...options) {
        var cb, progress, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (typeof completed === 'number' && typeof total === 'number' && completed >= 0 && total > 0 && total >= completed) {
          progress = {
            completed: completed,
            total: total,
            percent: 100 * completed / total
          };
          if (options.echo) {
            delete options.echo;
            this._echo(`PROGRESS: ${this._doc._id} ${this._doc.runId}: ${progress.completed} out of ${progress.total} (${progress.percent}%)`);
          }
          if ((this._doc._id != null) && (this._doc.runId != null)) {
            return methodCall(this._root, "jobProgress", [this._doc._id, this._doc.runId, completed, total, options], cb, (res) => {
              if (res) {
                this._doc.progress = progress;
              }
              return res;
            });
          } else if (this._doc._id == null) {
            this._doc.progress = progress;
            if ((cb != null) && typeof cb === 'function') {
              _setImmediate(cb, null, true); // DO NOT release Zalgo
            }
            return this;
          }
        } else {
          throw new Error(`job.progress: something is wrong with progress params: ${this.id}, ${completed} out of ${total}`);
        }
        return null;
      }

      // Save this job to the server job queue Collection it will also resave a modified job if the
      // job is not running and hasn't completed.
      save(...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        return methodCall(this._root, "jobSave", [this._doc, options], cb, (id) => {
          if (id) {
            this._doc._id = id;
          }
          return id;
        });
      }

      // Refresh the local job state with the server job queue's version
      refresh(...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.getLog == null) {
          options.getLog = false;
        }
        if (this._doc._id != null) {
          return methodCall(this._root, "getJob", [this._doc._id, options], cb, (doc) => {
            if (doc != null) {
              this._doc = doc;
              return this;
            } else {
              return false;
            }
          });
        } else {
          throw new Error("Can't call .refresh() on an unsaved job");
        }
      }

      // Indicate to the server that this run has successfully finished.
      done(result = {}, ...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        if (typeof result === 'function') {
          cb = result;
          result = {};
        }
        [options, cb] = optionsHelp(options, cb);
        if (!((result != null) && typeof result === 'object')) {
          result = {
            value: result
          };
        }
        if ((this._doc._id != null) && (this._doc.runId != null)) {
          return methodCall(this._root, "jobDone", [this._doc._id, this._doc.runId, result, options], cb);
        } else {
          throw new Error("Can't call .done() on an unsaved or non-running job");
        }
        return null;
      }

      // Indicate to the server that this run has failed and provide an error message.
      fail(result = "No error information provided", ...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        if (typeof result === 'function') {
          cb = result;
          result = "No error information provided";
        }
        [options, cb] = optionsHelp(options, cb);
        if (!((result != null) && typeof result === 'object')) {
          result = {
            value: result
          };
        }
        if (options.fatal == null) {
          options.fatal = false;
        }
        if ((this._doc._id != null) && (this._doc.runId != null)) {
          return methodCall(this._root, "jobFail", [this._doc._id, this._doc.runId, result, options], cb);
        } else {
          throw new Error("Can't call .fail() on an unsaved or non-running job");
        }
        return null;
      }

      // Pause this job, only Ready and Waiting jobs can be paused
      pause(...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (this._doc._id != null) {
          return methodCall(this._root, "jobPause", [this._doc._id, options], cb);
        } else {
          this._doc.status = 'paused';
          if ((cb != null) && typeof cb === 'function') {
            _setImmediate(cb, null, true); // DO NOT release Zalgo
          }
          return this;
        }
        return null;
      }

      // Resume this job, only Paused jobs can be resumed
      // Resumed jobs go to waiting
      resume(...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (this._doc._id != null) {
          return methodCall(this._root, "jobResume", [this._doc._id, options], cb);
        } else {
          this._doc.status = 'waiting';
          if ((cb != null) && typeof cb === 'function') {
            _setImmediate(cb, null, true); // DO NOT release Zalgo
          }
          return this;
        }
        return null;
      }

      // Make a waiting job ready to run. Jobs with dependencies only when forced
      ready(...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.force == null) {
          options.force = false;
        }
        if (this._doc._id != null) {
          return methodCall(this._root, "jobReady", [this._doc._id, options], cb);
        } else {
          throw new Error("Can't call .ready() on an unsaved job");
        }
        return null;
      }

      // Cancel this job if it is running or able to run (waiting, ready)
      cancel(...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.antecedents == null) {
          options.antecedents = true;
        }
        if (this._doc._id != null) {
          return methodCall(this._root, "jobCancel", [this._doc._id, options], cb);
        } else {
          throw new Error("Can't call .cancel() on an unsaved job");
        }
        return null;
      }

      // Restart a failed or cancelled job
      restart(...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.retries == null) {
          options.retries = 1;
        }
        if (options.dependents == null) {
          options.dependents = true;
        }
        if (this._doc._id != null) {
          return methodCall(this._root, "jobRestart", [this._doc._id, options], cb);
        } else {
          throw new Error("Can't call .restart() on an unsaved job");
        }
        return null;
      }

      // Run a completed job again as a new job, essentially a manual repeat
      rerun(...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (options.repeats == null) {
          options.repeats = 0;
        }
        if (options.wait == null) {
          options.wait = this._doc.repeatWait;
        }
        if (this._doc._id != null) {
          return methodCall(this._root, "jobRerun", [this._doc._id, options], cb);
        } else {
          throw new Error("Can't call .rerun() on an unsaved job");
        }
        return null;
      }

      // Remove a job that is not able to run (completed, cancelled, failed) from the queue
      remove(...options) {
        var cb, ref;
        ref = options, [...options] = ref, [cb] = splice.call(options, -1);
        [options, cb] = optionsHelp(options, cb);
        if (this._doc._id != null) {
          return methodCall(this._root, "jobRemove", [this._doc._id, options], cb);
        } else {
          throw new Error("Can't call .remove() on an unsaved job");
        }
        return null;
      }

    };

    // This is the JS max int value = 2^53
    Job.forever = 9007199254740992;

    // This is the maximum date value in JS
    Job.foreverDate = new Date(8640000000000000);

    Job.jobPriorities = {
      low: 10,
      normal: 0,
      medium: -5,
      high: -10,
      critical: -15
    };

    Job.jobRetryBackoffMethods = ['constant', 'exponential'];

    Job.jobStatuses = ['waiting', 'paused', 'ready', 'running', 'failed', 'cancelled', 'completed'];

    Job.jobLogLevels = ['info', 'success', 'warning', 'danger'];

    Job.jobStatusCancellable = ['running', 'ready', 'waiting', 'paused'];

    Job.jobStatusPausable = ['ready', 'waiting'];

    Job.jobStatusRemovable = ['cancelled', 'completed', 'failed'];

    Job.jobStatusRestartable = ['cancelled', 'failed'];

    Job.ddpMethods = [
      'startJobs',
      'stopJobs', // Deprecated!
      'startJobServer',
      'shutdownJobServer',
      'jobRemove',
      'jobPause',
      'jobResume',
      'jobReady',
      'jobCancel',
      'jobRestart',
      'jobSave',
      'jobRerun',
      'getWork',
      'getJob',
      'jobLog',
      'jobProgress',
      'jobDone',
      'jobFail'
    ];

    Job.ddpPermissionLevels = ['admin', 'manager', 'creator', 'worker'];

    // These are the four levels of the allow/deny permission heirarchy
    Job.ddpMethodPermissions = {
      'startJobs': [
        'startJobs',
        'admin' // Deprecated!
      ],
      'stopJobs': [
        'stopJobs',
        'admin' // Deprecated!
      ],
      'startJobServer': ['startJobServer', 'admin'],
      'shutdownJobServer': ['shutdownJobServer', 'admin'],
      'jobRemove': ['jobRemove', 'admin', 'manager'],
      'jobPause': ['jobPause', 'admin', 'manager'],
      'jobResume': ['jobResume', 'admin', 'manager'],
      'jobCancel': ['jobCancel', 'admin', 'manager'],
      'jobReady': ['jobReady', 'admin', 'manager'],
      'jobRestart': ['jobRestart', 'admin', 'manager'],
      'jobSave': ['jobSave', 'admin', 'creator'],
      'jobRerun': ['jobRerun', 'admin', 'creator'],
      'getWork': ['getWork', 'admin', 'worker'],
      'getJob': ['getJob', 'admin', 'worker'],
      'jobLog': ['jobLog', 'admin', 'worker'],
      'jobProgress': ['jobProgress', 'admin', 'worker'],
      'jobDone': ['jobDone', 'admin', 'worker'],
      'jobFail': ['jobFail', 'admin', 'worker']
    };

    // Automatically work within Meteor, otherwise see @setDDP below
    Job._ddp_apply = void 0;

    // This is defined above
    Job.processJobs = JobQueue;

    // Makes a job object from a job document
    // This method is deprecated and will be removed
    Job.makeJob = (function() {
      var depFlag;
      depFlag = false;
      return function(root, doc) {
        if (!depFlag) {
          depFlag = true;
          console.warn("Job.makeJob(root, jobDoc) has been deprecated and will be removed in a future release, use 'new Job(root, jobDoc)' instead.");
        }
        return new Job(root, doc);
      };
    })();

    // Define convenience getters for some document properties
    Object.defineProperties(Job.prototype, {
      doc: {
        get: function() {
          return this._doc;
        },
        set: function() {
          return console.warn("Job.doc cannot be directly assigned.");
        }
      },
      type: {
        get: function() {
          return this._doc.type;
        },
        set: function() {
          return console.warn("Job.type cannot be directly assigned.");
        }
      },
      data: {
        get: function() {
          return this._doc.data;
        },
        set: function() {
          return console.warn("Job.data cannot be directly assigned.");
        }
      }
    });

    return Job;

  }).call(this);

  // Export Job in a npm package
  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Job;
  }

}).call(this);
